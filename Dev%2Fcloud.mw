{{Header}}
{{title|title=
{{project_name_long}} for Cloud
}}
{{#seo:
|description={{project_name_short}} in the cloud - Development Considerations
}}
{{intro|
{{project_name_short}} in the cloud - Development Considerations
}}
= Confidential VMs =
* TRESOR: https://www.cs1.tf.fau.de/research/system-security-group/tresor-trevisor-armored/ Provides full disk encryption functionality using an encryption key that is stored in CPU registers rather than RAM.
* RamCrypt: https://faui1-files.cs.fau.de/filepool/projects/ramcrypt/ramcrypt.pdf Encrypts the RAM of Linux userland processes using a modified form of TRESOR, again keeping the core encryption key in CPU registers.
* pKVM: https://lwn.net/Articles/890224/, https://source.android.com/docs/core/virtualization/architecture, https://lwn.net/Articles/836693/ Makes it difficult for the host kernel to access the RAM of virtual machines. arm64-specific, designed for Android.
* Goal is to be able to run virtual machines in the cloud in a manner resistant to cold-boot attacks.
* Investigate theoretical practicality, feasibility of implementation, and potential issues.
* Shortcomings in current TRESOR implementation that would need to be overcome:
** The encryption password is read by the kernel during early bootup. This requires manual user intervention on every boot. Ideally, an implementation of TRESOR would be able to read a scrambled form of the encryption key from a device, store it in the CPU, then await the input of a descramble key that can be used to "arm" the TRESOR key. This would allow existing methods of booting an encrypted system unattended to function properly and would also allow using a stronger algorithm than SHA256 for converting the password to a key (SHA256 is so fast that it's prone to bruteforcing if the password isn't long enough. Something like Argon2id would be much more desirable here).
** At most one AES-256 encryption key can be stored at once, since TRESOR stores the key in CPU debug registers and there are only 256 bits of information in those registers. This makes it difficult to use TRESOR with more than one encrypted disk. In my opinion, ideally there should be a number of "slave" keys that can be decrypted by the TRESOR master key, allowing multiple encrypted disk devices to be used.
* TRESOR shortcomings that cannot be overcome and require working with:
** TRESOR only works on physical hardware; it cannot be used securely on virtual machines. For obvious reasons, vCPUs have their registers written to the host's RAM frequently, including the debug registers that TRESOR relies upon. Thus, the use of TRESOR for cloud VM hosting would require cooperation from a hosting provider.
** Root access is sufficient to access the debug registers and extract the key if /dev/kmem is accessible or if it is possible to load kernel modules. Thus, a custom kernel is needed to use TRESOR securely, one with all drivers compiled in, modules disabled, and /dev/kmem absent.
* Shortcomings in RamCrypt that cannot be overcome and require working with:
** RamCrypt only adds an extra barrier of difficulty to an attack, it does not meaningfully prevent one. Part of an encrypted process's memory is left in decrypted form in RAM for brief periods of time.
*** This is because a process naturally cannot directly read and use encrypted memory. That memory must be decrypted first and written where the process can access it. In the case of an nginx server given in the paper, a critical encryption key used by the server was exposed 3% of the time, which doesn't seem like much but still gives a solid chance of a successful attack, especially if the attacker can time the attack carefully.
*** Decrypted data is saved to RAM because there isn't many other places it can go. There isn't enough room in CPU registers to save it (TRESOR only barely manages to fit a single AES key into the debug registers). Saving it in cache is potentially possible but very tricky. By default, RamCrypt only allows four 4k pages of RAM to be decrypted at any one time, although this number can be configured by the user.
*** Use of CPU cache as a temporary form of RAM is doable - a technique known as "cache-as-RAM" can be used and in practice is used in low-level code such as Coreboot. (https://stackoverflow.com/a/41775588) However, enabling cache-as-RAM causes serious limitations that may make it impractical. (https://stackoverflow.com/a/62221840, "...you can't use DRAM at all when no-fill-mode is activated. i.e. only cache is available, and you have to be careful not to evict anything that was cached. It's not usable for any practical purpose except early-boot.") Keeping actively executing program data in cache may be theoretically doable, but could be impractical. (https://frozencache.blogspot.com/ provides some instructions on how to use cache as RAM on a running Linux system, the data is very old but potentially still usable)
** Where TRESOR provides a performance *increase*, RamCrypt comes with a substantial performance *hit* of at least 25% in the benchmarks shown. That's with single-threaded workloads and a maximum of 4 pages of RAM unencrypted at any one time. As thread count gets higher, the hit increases dramatically, and to decrease it, one must allow more pages of RAM to be simultaneously decrypted, reducing security.
* pKVM is not an encryption-based feature; rather, it makes use of page table magic and isolation between ARM code privilege levels to keep the host from accessing the guest's memory easily. It will not prevent cold-boot attacks. It may be compatible with RamCrypt, however. It does NOT rely on remote attestation. It does seem to rely on Verified Boot (https://source.android.com/docs/security/features/verifiedboot), however Verified Boot is used by non-Google Android ROMs such as GrapheneOS as well and isn't a privacy-invasive feature. It does not appear to require the host OS to be locked down.
* Rough time estimate: possibly around 240 hours of actual time invested (four hours a day, five days a week, for three months). This is a '''very''' rough estimate since actual time will depend on how receptive the kernel devs are to the ideas and how much effort is required to polish their implementation to a usable state.

= Secure Cloud Hardware TODO Research List =
== RAM Encryption ==
* PrivateCore
** https://en.wikipedia.org/wiki/PrivateCore
** https://privatecore.com/vcage/index.html
* Microsoft
** https://learn.microsoft.com/en-us/windows/security/information-protection/pluton/microsoft-pluton-security-processor
** https://azure.microsoft.com/en-us/products/key-vault/
** https://azure.microsoft.com/en-us/solutions/confidential-compute/#solution-architectures
** https://www.microsoft.com/en-us/research/project/microsoft-seal/
* Google
** https://cloud.google.com/security-key-management
** https://cloud.google.com/confidential-computing
* raptorengineering
** https://www.raptorengineering.com/TALOS/documentation/integrimon_intro.pdf
** https://www.raptorengineering.com/TALOS/security_features.php
** https://www.crowdsupply.com/raptor-computing-systems/talos-secure-workstation/updates/talos-fpga-functions-and-responsibilities-part-1
** https://www.crowdsupply.com/raptor-computing-systems/talos-secure-workstation/updates/talos-fpga-functions-and-responsibilities-part-2
** https://www.integricloud.com/
* HashiCorp
** https://www.vaultproject.io/
* thales
** https://cpl.thalesgroup.com/cloud-security
* AWS
** https://aws.amazon.com/security/cryptographic-computing/
** https://aws.amazon.com/clean-rooms/features/
* https://en.wikipedia.org/wiki/Key_Management_Interoperability_Protocol
* KVM
* pKVM - protected KVM
** https://lwn.net/Articles/890224/

== Homomorphic Encryption ==

* https://en.wikipedia.org/wiki/Homomorphic_encryption
* Microsoft
** https://learn.microsoft.com/en-us/azure/architecture/solution-ideas/articles/homomorphic-encryption-seal
* AWS
** https://aws.amazon.com/security/cryptographic-computing/

[[Category:Design]]
{{Footer}}